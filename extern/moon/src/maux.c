#define LUA_CORE

#include "maux.h"

#include <setjmp.h>

#include "lauxlib.h"

#include "moutput.h"

static jmp_buf custom_lua_panic_jump;

static int custom_lua_atpanic(lua_State *L) {
  const char *msg = lua_tostring(L, -1);
  if (msg == NULL) msg = "error object is not a string";
  moon_writestringerror(L, "PANIC: unprotected error in call to Lua API (%s)\n", msg);
  longjmp(custom_lua_panic_jump, 1); /* will never return */
  return 0;  /* return to Lua to abort */
}

/*
** Message handler used to run all chunks
*/
static int msghandler (lua_State *L) {
  const char *msg = lua_tostring(L, 1);
  if (msg == NULL) {  /* is error object not a string? */
    if (luaL_callmeta(L, 1, "__tostring") &&  /* does it have a metamethod */
        lua_type(L, -1) == LUA_TSTRING)  /* that produces a string? */
      return 1;  /* that is the message */
    else
      msg = lua_pushfstring(L, "(error object is a %s value)",
                            luaL_typename(L, 1));
  }
  luaL_traceback(L, L, msg, 1);  /* append a standard traceback */
  return 1;  /* return the traceback */
}

/*
** Interface to 'lua_pcall', which sets appropriate message function
** and C-signal handler. Used to run all chunks.
*/
static int docall (lua_State *L, int narg, int nres) {
  int status;
  int base = lua_gettop(L) - narg;  /* function index */
  lua_pushcfunction(L, msghandler);  /* push message handler */
  lua_insert(L, base);  /* put it under function and args */
  status = lua_pcall(L, narg, nres, base);
  lua_remove(L, base);  /* remove message handler from the stack */
  /* force a complete garbage collection in case of errors */
  if (status != LUA_OK) lua_gc(L, LUA_GCCOLLECT, 0);
  return status;
}

/*
** Create the 'arg' table, which stores all arguments from the
** command line ('argv').
*/
static void create_arg_table(lua_State *L, int argc, char **argv)
{
  int i;
  lua_createtable(L, argc, 0);
  if (argv != NULL) {
    for (i = 0; i < argc; i++) {
      if (argv[i] == NULL) break;
      lua_pushstring(L, argv[i]);
      lua_rawseti(L, -2, i + 1);
    }
  }
  lua_setglobal(L, "arg");
}

/*
** Push on the stack the contents of table 'arg'
*/
static int push_args_stack(lua_State *L) {
  int narg = 0;
  lua_getglobal(L, "arg");
  if (lua_istable(L, -1)) {
    narg = lua_objlen(L,-1);
    luaL_checkstack(L, narg + 3, "too many arguments to script");
    int i;
    for (i = 1; i <= narg; i++) {
      lua_rawgeti(L, -i, i);
    }
    lua_remove(L, -i);  /* remove table from the stack */
  } else {
    luaL_error(L, "'arg' is not a table");
  }
  return narg;
}

/*
** Check whether 'status' is not OK and, if so, prints the error
** message on the top of the stack. It assumes that the error object
** is a string, as it was either generated by Lua or by 'msghandler'.
*/
static int report (lua_State *L, int status) {
  if (status != LUA_OK) {
    const char *msg = lua_tostring(L, -1);
    if (msg == NULL) msg = "(error object is not a string)";
    moon_writestringerror(L, "%s\n", msg);
    lua_pop(L, 1);  /* remove message */
  }
  return status;
}

int moon_doscript(lua_State *L, int argc, char *argv[], const char *script, size_t size)
{
  int ret = 1;
  /* set custom panic handler for unhandled errors */
  lua_CFunction original_panic = lua_atpanic(L, &custom_lua_atpanic);
  if (setjmp(custom_lua_panic_jump) == 0) {
    int status;
    create_arg_table(L, argc, argv);
    status = luaL_loadbuffer(L, script, size, "");
    if (status == LUA_OK) {
      /* Fetch args from arg table and push onto stack */
      int narg = push_args_stack(L);
      /* Execute and hope for the best... */
      status = docall(L, narg, LUA_MULTRET);
    }
    ret = report(L, status);
  }
  else { /* custom panic function called */ }
  lua_atpanic(L, original_panic);
  return ret;
}

void moon_printstack(lua_State *L) {
  printf("+==========  STACK  ==========+\n");
  int top=lua_gettop(L);
  for (int i=1; i <= top; i++) {
    printf("%d\t%s\t", i, luaL_typename(L,i));
    switch (lua_type(L, i)) {
      case LUA_TNUMBER:
        printf("%g\n",lua_tonumber(L,i));
        break;
      case LUA_TSTRING:
        printf("%s\n",lua_tostring(L,i));
        break;
      case LUA_TBOOLEAN:
        printf("%s\n", (lua_toboolean(L, i) ? "true" : "false"));
        break;
      case LUA_TNIL:
        printf("%s\n", "nil");
        break;
      default:
        printf("%p\n",lua_topointer(L,i));
        break;
    }
  }
  printf("+=============================+\n");
}
